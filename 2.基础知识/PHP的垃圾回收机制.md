PHP的垃圾回收机制
```
引用计数

1、每一个变量定义时都保存在一个叫zval的容器里面，这里面包含了数量的类型和和值，
    还包含了一个refcount（理解为存在几个变量个数）和is_ref（理解为是否为引用变量）两个额外信息，
    当变量被引用一次refcount就会+1，当你unset一下之后这个值就会减1直到为0就会从内存中删除。

2、定义一个变量的时候并不是每次都会扩大预定于值，因为PHP会在内存中先预占用一个空间，
    等你声明变量的时候就会分配给你，但是当你超出这个预占用空间之后，那么它就会增加空间，
    但是等你删除变量时候这个空间容量不会立即消失

3、变量的引用不会单独的多增加内存占用，它会指向zval结构体，只是refcount+1

4、简单说说，PHP的变量依赖于一个内部实现 symbol_table 符号表，而符号表的基础实现是 HashTable ，
    也就是和PHP数组的基础实现是一致的。正是因为符号表的存在，让我们可以使用global标记全局变量，
    用如compact等函数直接从当前符号表中拉出变量出来。

那在谈谈题主说的unset($a)会不会马上释放空间，答案是否定的，unset支持从符号表中把名字为a的这个元素删掉了
（只是标记这块空间又可用了，而不是释放空间）。

再说循环中重复更新$key这种情况，因为更新的是相同名字的变量，所以在符号表中他们是同一个元素，
更新时就会更新相同的位置，之前元素的值就马上被覆盖了。

再说说申明了新的变量内存就会增加这个问题，答案是不确定。这是符号表基于 HashTable 实现的特性所致，
HashTable 并不是增加一个元素就申请一个元素的内存，而是一次申请多个元素的内存（只是这些位置标记是未使用），
而当 HashTable 被塞满时，再去申请新的多个元素的内存。也就是说，当我们申明或者赋值一个变量时，
如果它不在符号表中，PHP会将它加入到符号表里，而如果这时候符号表没满，那会采用符号表中已申请而未使用的内存，
如果符号表刚好的满的，则会申请新的内存出来存放，而新的内存不仅仅只有这个变量需要的内存这么小。

```

