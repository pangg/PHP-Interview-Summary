MySQL查询优化

1. 分析sql查询慢的方法
    （1）记录慢查询日志
        分析查询日志，不要直接打开慢查询日志进行分析，可以使用pt-query-digest工具进行分析

    （2）使用show profile
         set profile=1;开启，服务器上执行的所有语句会检测消耗的时间，存到临时表中
         show profiles
         show profile for query 临时表ID

    （3）使用show status
        show status会返回一些计数器，
        show global status 查看服务器级别的所有计数
        有时根据这些计数，可以猜测出哪些操作代价较高或者消耗时间多

    （4）使用show processlist
        观察是否有大量线程处于不正常的状态或者特征

2. explain
    分析单条sql语句

3. 优化查询过程中的数据访问
    （1）访问数据太多导致查询性能下降
        确定应用程序是否在检索大量超过需要的数据，可能是太多行或者列
        确认MySQL服务器是否在分析大量不必要的数据行
    （2）避免使用如下sql语句
        查询不需要的记录，使用limit解决
        多表关联返回全部列，指定A.id，A.name，B.age
        总是取出全部列，select * 会让优化器无法完成索引覆盖扫描的优化
        重复查询相同的数据，可以缓存数据，下次直接读取缓存
    （3）是否在扫描额外的记录
        使用explain来进行分析，如果发现查询需要扫描大量的数据但只返回少数的行，可以通过如下技巧优化：
        使用索引覆盖扫描，把所有用的列都放到索引当中，这样存储引擎不需要回表获取对应行就可以返回结果
        改写数据库和表的结构，修改数据表范式
        重写sql语句，让优化器可以以更优的方式执行查询

        MySQL数据库三大范式：
        第一范式：字段的原子性：简单来说就是每一个字段不能分割出其他的属性（确保每列的原子性）
        第二范式：保证主键的唯一性，属性完全依赖于主键
                在第一范式的基础上更进一层,目标是确保表中的每列都和主键相关
        第三范式：消除传递依赖，保证每个属性都直接依赖于主键

4. 优化长难的查询语句
    （1）一个复杂查询还是多个简单查询
        MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多
        使用尽可能少的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的
    （2）切分查询
        将一个大的查询分为多个小的相同的查询
        一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销
    （3）分解关联查询
        可以将一条关联语句分解成多条sql来执行
        让缓存的效率更高
        执行单个查询可以减少锁的竞争
        在应用层做关联可以更容易对数据库进行拆分
        查询效率会有大幅提升
        较少冗余记录的查询

5. 优化特定类型的查询语句
    （1）优化count()查询
        count(*)中的*会忽略所有的列，直接统计所有列数，因此不要使用count(列名)
        MyISAM中，没有任何where条件的count(*)非常快
        当where条件，MyISAM的count统计不一定比其他表引擎快
        可以使用explain查询近似值，用近似值代替count(*)
        增加汇总表
        使用缓存
    （2）优化关联查询
        确定on或者using子句的列上有索引
        确保group by和order by中只有一个表中的列，这样MySQL才有可能使用索引
    （3）优化子查询
        尽可能使用关联查询来代替
    （4）优化group by 和 distinct
        这两种查询均可使用索引来优化，是最有效的优化方法
        关联查询中，使用标识列进行分组的效率会更高
        如果不需要order by，进行group by时使用order by null，MySQL不会在进行文件排序
        with rollup超级聚合，可以挪到应用程序处理
    （5）优化limit分页
        limit偏移量大的时候，查询效率较低
        可以记录上次查询的最大id，下次查询时直接根据该id来查询（上次Max(id)=10000,则下次查询可加条件where id>10000 limit 100）
    (6)优化union查询
       union all的效率高于union（因此去重可以放在应用层）
















