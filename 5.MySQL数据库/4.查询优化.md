MySQL查询优化

1. 分析sql查询慢的方法
    * （1）记录慢查询日志
        * 分析查询日志，不要直接打开慢查询日志进行分析，可以使用pt-query-digest工具进行分析

    * （2）使用show profile
         * set profile=1;开启，服务器上执行的所有语句会检测消耗的时间，存到临时表中
         * show profiles
         * show profile for query 临时表ID

    * （3）使用show status
        * show status会返回一些计数器，
        * show global status 查看服务器级别的所有计数
        * 有时根据这些计数，可以猜测出哪些操作代价较高或者消耗时间多

    * （4）使用show processlist
        * 观察是否有大量线程处于不正常的状态或者特征

2. explain
    * 分析单条sql语句

3. 优化查询过程中的数据访问
    * （1）访问数据太多导致查询性能下降
        * 确定应用程序是否在检索大量超过需要的数据，可能是太多行或者列
        * 确认MySQL服务器是否在分析大量不必要的数据行
    * （2）避免使用如下sql语句
        * 查询不需要的记录，使用limit解决
        * 多表关联返回全部列，指定A.id，A.name，B.age
        * 总是取出全部列，select * 会让优化器无法完成索引覆盖扫描的优化
        * 重复查询相同的数据，可以缓存数据，下次直接读取缓存
    * （3）是否在扫描额外的记录
        * 使用explain来进行分析，如果发现查询需要扫描大量的数据但只返回少数的行，可以通过如下技巧优化：
        * 使用索引覆盖扫描，把所有用的列都放到索引当中，这样存储引擎不需要回表获取对应行就可以返回结果
        * 改写数据库和表的结构，修改数据表范式
        * 重写sql语句，让优化器可以以更优的方式执行查询


        * MySQL数据库三大范式：
            * 第一范式：字段的原子性：简单来说就是每一个字段不能分割出其他的属性（确保每列的原子性）
            * 第二范式：保证主键的唯一性，属性完全依赖于主键
                    在第一范式的基础上更进一层,目标是确保表中的每列都和主键相关
            * 第三范式：消除传递依赖，保证每个属性都直接依赖于主键

4. 优化长难的查询语句
    * （1）一个复杂查询还是多个简单查询
        * MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多
        * 使用尽可能少的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的
    * （2）切分查询
        * 将一个大的查询分为多个小的相同的查询
        * 一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销
    * （3）分解关联查询
        * 可以将一条关联语句分解成多条sql来执行
        * 让缓存的效率更高
        * 执行单个查询可以减少锁的竞争
        * 在应用层做关联可以更容易对数据库进行拆分
        * 查询效率会有大幅提升
        * 较少冗余记录的查询

5. 优化特定类型的查询语句
    * （1）优化count()查询
        * count(*)中的*会忽略所有的列，直接统计所有列数，因此不要使用count(列名)
        * MyISAM中，没有任何where条件的count(*)非常快
        * 当where条件，MyISAM的count统计不一定比其他表引擎快
        * 可以使用explain查询近似值，用近似值代替count(*)
        * 增加汇总表
        * 使用缓存
    * （2）优化关联查询
        * 确定on或者using子句的列上有索引
        * 确保group by和order by中只有一个表中的列，这样MySQL才有可能使用索引
    * （3）优化子查询
        * 尽可能使用关联查询来代替
    * （4）优化group by 和 distinct
        * 这两种查询均可使用索引来优化，是最有效的优化方法
        * 关联查询中，使用标识列进行分组的效率会更高
        * 如果不需要order by，进行group by时使用order by null，MySQL不会在进行文件排序
        * with rollup超级聚合，可以挪到应用程序处理
    * （5）优化limit分页
        * limit偏移量大的时候，查询效率较低
        * 可以记录上次查询的最大id，下次查询时直接根据该id来查询（上次Max(id)=10000,则下次查询可加条件where id>10000 limit 100）
    * (6)优化union查询
       * union all的效率高于union（因此去重可以放在应用层）


-----------------------------------------------------------------------------------------------------------------------------------------------------

6. MySQL数据库优化的八种方式：
    * 1、选取最适用的字段属性： 将表中字段的宽度设得尽可能小
    * 2、使用连接（JOIN）来代替子查询(Sub-Queries)
    * 3、使用联合(UNION)来代替手动创建的临时表
    * 4、事务：保持数据库中数据的一致性和完整性
    * 5、锁定表：
        * 尽管事务是维护数据库完整性的一个非常好的方法，但却因为它的独占性，有时会影响数据库的性能，尤其是在很大的应用系统中。
        由于在事务执行的过程中，数据库将会被锁定，因此其它的用户请求只能暂时等待直到该事务结束。
        大访问量会产生比较严重的响应延迟； 有些情况下我们可以通过锁定表的方法来获得更好的性能。
        ```
        LOCK TABLE inventory WRITE SELECT quantity  FROM   inventory   WHERE Item='book';
        ...
        UPDATE   inventory   SET   Quantity=11   WHERE  Item='book';UNLOCKTABLES
        ```
    * 6、使用外键：
        * 锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性。
    * 7、使用索引：
    * 8、优化的查询语句：
        * a、 首先，最好是在相同类型的字段间进行比较的操作
        * b、 其次，在建有索引的字段上尽量不要使用函数进行操作
        * c、第三，在搜索字符型字段时，我们有时会使用LIKE关键字和通配符，这种做法虽然简单，但却也是以牺牲系统性能为代价的

7. 优化Mysql查询优化
    * 1、创建索引
    * 2、复合索引
    * 3、索引尽量不要包含有NULL值的列:
        * column is null 可以使用索引，但同时在两个字段对null进行判断，还是会走全表扫描
        * 复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。
        * 所以我们在数据库设计时不要让字段的默认值为NULL。
    * 4、使用短索引:
        * 对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，
        * 多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。
    * 5、排序的索引问题：
        * mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。
        * 因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。
    * 6、like语句操作
        * 一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。
    * 7、不要在列上进行运算
        * select * from users where YEAR(adddate)<2007;
        * 将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成
        * select * from users where adddate<‘2007-01-01';
    * 8、不使用NOT IN和<>操作
        * NOT IN和<>操作都不会使用索引将进行全表扫描。NOT IN可以NOT EXISTS代替，id<>3则可使用id>3 or id<3来代替。


8. MySQL查询过程:
![MySQL查询过程](https://github.com/pangg/PHP-Interview-Summary/blob/master/5.MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B.png)

--------------------------------------------------------------------------------------------------------------------------------------------------------------

9. 数据库SQL优化大总结:
    1.对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。
    3.应尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描。
    4.应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，如：
        ```
        select id from t where num=10 or Name = 'admin'
        可以这样查询：
        select id from t where num = 10
        union all
        select id from t where Name = 'admin'
        ```
    5.in 和 not in 也要慎用，否则会导致全表扫描，如：
    ```
        select id from t where num in(1,2,3)
        对于连续的数值，能用 between 就不要用 in 了：
        select id from t where num between 1 and 3
        很多时候用 exists 代替 in 是一个好的选择：
        select num from a where num in(select num from b)
        用下面的语句替换：
        select num from a where exists(select 1 from b where num=a.num)
        ```
    6.下面的查询也将导致全表扫描：
        select id from t where name like ‘%abc%’
        若要提高效率，可以考虑全文检索。
    7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。
        然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：
        ```
        select id from t where num = @num
        可以改为强制查询使用索引：
        select id from t with(index(索引名)) where num = @num
        ```
    8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：
    ```
        select id from t where num/2 = 100
        应改为:
        select id from t where num = 100*2
        ```
    9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：
    ```
        select id from t where substring(name,1,3) = 'abc'       -–name以abc开头的id
        select id from t where datediff(day,createdate, '2005-11-30') = 0    -–‘2005-11-30’    --生成的id
        应改为:
        select id from t where name like 'abc%'
        select id from t where createdate >= '2005-11-30' and createdate < '2005-12-1'
        ```
    10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。
    11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，
        否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。
    12.不要写一些没有意义的查询，如需要生成一个空表结构：
    ```
        select col1,col2 into #t from t where 1=0
        这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：
        create table #t(…)
        ```
    13.Update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。
    14.对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。
    15.select count(*) from table；这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的。
    16.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，
        所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。
    17.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，
        会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。
    18.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。
        这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。
    19.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，
        在一个相对较小的字段内搜索效率显然要高些。
    20.任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。
    22. 避免频繁创建和删除临时表，以减少系统表资源的消耗。临时表并不是不可使用，适当地使用它们可以使某些例程更有效，
        例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。
    23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，
        以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。
    24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。

    25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。

    26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。

    27.与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。

    28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。

    29.尽量避免大事务操作，提高系统并发能力。

    30.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。












