动态语言并发处理

1. 进程 是计算机中的程序关于某数据集合上的一次运行活动，
    是系统进行资源分配的和调度的基本单位，是操作系统结构的基础。
    进程是一个 “执行中的程序”。
    进程的三态模型：多道程序系统中，进程在处理器上交替运行，状态不断发生变化。
    运行， 就绪， 阻塞

    运行：当一个进程在处理机上运行时，则称该进程处于运行状态。处于此状态
        的进程数目小于等于处理器的数目，对于单处理机系统，处于运行状态的
        进程只有一个。在没有其他进程可以执行时（如所有进程都在阻塞状态），
        通常会自动执行系统的空闲进程。
    就绪：当一个进程获得了处理机以外的一切所需资源，一旦得到处理机即可运行，则
        称此进程处于就绪状态。就绪进程可以按多个优先级来划分队列。如，当一个进程由于时间片
        用完而进入就绪状态时，排入低优先级队列；当进程由i/o操作完成而进入
        就绪状态时，排入高级优先队列。
    阻塞：也称等待或睡眠状态，一个进程正在等待某一事件发生（如请求i/o而等待i/o
        完成）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称进程处于阻塞状态。

2. 线程
        有时被称为轻量级进程，是程序执行流的最小单位。
        线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，
    只拥有一点在运行中必不可少的资源但它可与同属一个进程的其他线程共享进程所拥有
    的全部资源。
        一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可并发执行。
        线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，
    是系统独立调度和分派CPU的基本单位（指运行中的程序的调度单位）。
        在单个程序中同时运行多个线程完成不同的工作，称为多线程。
        每个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。

        线程的状态：就绪、 阻塞、 运行
        就绪状态：线程具备运行的所有条件，逻辑上可以运行，在等待处理机。
        运行状态：线程占有处理机正在运行。
        阻塞状态：线程在等待一个事件（如某个信号量），逻辑上不可执行。

3. 协程
        协程是一种用户态的轻量级线程，协程的调度完全由用户控制。
    协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存
    到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈
    则基本没有内核切换的开销，可以不加锁的访问全文变量，所以上下文的切换非
    常快。

4. 线程和进程的区别
    （1）线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，
        而进程有自己独立的地址空间。
    （2）进程是资源分配和拥有的单位，同一个进程内的线程共享进程的资源。
    （3）线程是处理器调度的基本单位，但进程不是。
    （4）二者均可并发执行
    （5）每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能
        够独立运行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

5. 线程与协程区别
    （1）一个线程可以多个协程，一个进程也可以单独拥有多个协程
    （2）线程进程都是同步机制，而协程则是异步；
    （3）协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。

6. 多进程、多线程
    多进程：
        同一时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，就是多进程。
        边看视频边用WebIDE。
        多开一个进程，多分配一份资源，进程间通讯不方便。
    多线程：
        线程就是把一个进程分为很多片，每一片都可以是一个独立的流程；
        与多进程的区别是只会使用一个进程的资源，线程间可以直接通讯；

7. 概念之间的区别
    单进程单线程：一个人在一个桌子上吃饭；
    单进程多线程：多个人在同一个桌子上一起吃饭；
    多进程单线程：多个人每个人在自己的桌子上吃菜；

8. 同步阻塞
    多进程：
            最早的服务器端程序都是通过多进程、多线程来解决并发IO的问题；
            一个请求创建一个进程，然后子进程进入循环同步堵塞地与客户端连接进行交互，
        收发处理数据。
    多线程：
        用多线程模拟实现非常简单，线程中可以直接向某一个客户端连接发送数据；


    步骤：
        （1）创建一个socket；
        （2）进入while循环，阻塞在进程accept操作上，等待客户端连接进入；
        （3）主进程在多进程模型下通过fork创建子进程
        （4）多线程模型下可以创建子线程
        （5）子进程/线程创建成功后进入while循环，阻塞在recv调用上，等待客户端向
            服务器发送数据
        （6）收到数据后服务器程序进行处理然后使用send向客户端发送响应
        （7）当客户端连接关闭时，子进程/线程退出并销毁所有资源。主进程/线程会
            回收掉此子进程/线程。
    缺点：
        这种模型严重依赖进程的数量解决并发问题；
        启动大量进程会带来额外的进程调度消耗；


    //创建socket监听
    $sockserv = stream_socket_server('tcp://0.0.0.0:8000', $errno, $errstr);
    for($i=0; $i < 5; $i++){
        if(pcntl_fork() == 0){
            while(true){
                $conn = stream_socket_accept($sockserv);
                if($conn == false){
                    continue;
                }
                $request = fread($conn, 9000);
                $response = 'hello';
                fwrite($conn, $response);
                fclose($conn);
            }
            exit(0);
        }
    }

9. 异步非阻塞
        现在各种高并发异步IO的服务器程序都是基于epoll实现的；
        IO复用异步非阻塞程序使用经典的Reactor模型，Reactor是反应堆的意思，
    它本身不处理任何数据收发。只是可以监视一个socket句柄的事件变化。

    Reactor模型
        Add: 添加一个socket到reactor
        Set：修改socket对应的事件，如可读可写
        Del：从Reactor中移除
        Callback：事件发生后回调指定的函数

    Reactor 的4个核心操作：
        （1）add添加socket监听到reactor
        （2）set修改事件监听，可以设置监听的类型，如可读可写
        （3）del从reactor中移除，不再监听事件
        （4）callback，事件发生后对应的处理逻辑，一般在add/set时定制

    Nginx：多线程Reactor
    Swoole：多线程Reactor + 多线程Worker

10. PHP并发编程实践
    1）PHP的Swoole扩展
            PHP的异步、并行、高性能网络通信引擎，使用纯C语言编写，
        提供了PHP语言的异步多线程服务器，异步TCP/UDP网络客户端，异步
        MySql，异步redis，数据库连接池，AsyncTask，消息队列，毫秒定时器，
        异步文件读写，异步DNS查询。
            除了异步IO的支持之外，Swoole为PHP多进程的模式设计了多个并发数据结构和IPC通讯机制，
        可以大大简化多进程并发编程的工作。
            Swoole2.0支持了类似Go语言的协程，可以使用完全同步的代码实现异步程序；

    2）消息队列
        场景：用户注册后，需要发注册邮件和注册短信；
        串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信；
        并行方式：将注册信息写入数据库成功后，发送邮件的同时发送短信；

        消息队列方式：将注册信息写入数据库成功后，将成功信息写入队列，此时直接返回成功给用户，
    写入队列的时间非常短，可以忽略不计，然后异步发送邮件和短信；

        应用解耦：
            场景：用户下单后，订单系统需要通知库存系统；
                假如库存系统无法访问，则订单减库存将失败，从而导致订单失败
                订单系统与库存系统耦合
            引用队列：
                    用户下单后，订单系统完成持久化处理，将消息写入消息队列，
                返回用户订单下单成功；
                    订阅下单消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，
                进行库存操作；

        流量削锋：
            场景：秒杀活动，流量瞬间激增，服务器压力大；
                    用户发起请求，服务器接收后，先写入消息队列。假如消息队列长度超过最大值，
                则直接报错或提示用户；后续程序读取消息队列再做处理；

            控制请求量，缓解高流量

        日志处理：
            场景：解决大量日志传输；
                日志采集程序将程序写入消息队列，然后通过日志处理程序的订阅消费日志；

        消息通讯：
            场景： 聊天室
            多个客户端订阅同一主题，进行消息发布和接收；

    3）接口的并发请求
        curl_multi_init























