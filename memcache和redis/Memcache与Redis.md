```
一、 Memcache与Redis的区别
    1)、存储方式
        Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。
        Redis有部份存在硬盘上，这样能保证数据的持久性。
    2)、数据支持类型
        Memcache对数据类型支持相对简单。
        Redis有复杂的数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)
    3)、使用底层模型不同
        它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。
        Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
    4)、value大小
        Redis: 一个key或是value大小最大是512M;
        memcached的简单限制就是键（key）和item的限制。最大键长为250个字符。可以接受的储存数据不能超过1MB，因为这是典型slab 的最大值。

二、 数据类型
    String：缓存、限流、计数器、分布式锁、分布式Session
    Hash：存储用户信息、用户主页访问量、组合查询
    List：微博关注人时间轴列表、简单队列
    Set：赞、踩、标签、好友关系
    Zset：排行榜

    1. String数据
        常用命令：set/get/decr/incr/mget 等；
        应用场景：String 是最常用的一种数据类型，普通的 key/value 存储都可以归为此类；
        实现方式：String 在 redis 内部存储默认就是一个字符串，被 redisObject 所引用，当遇到 incr、decr 等操作时会转成数值型进行计算，此时 redisObject 的 encoding 字段为 int。

    2. Hash数据
       常用命令：hget/hset/hgetall 等
       应用场景：我们要存储一个用户信息对象数据，其中包括用户 ID、用户姓名、年龄和生日，通过用户 ID 我们希望获取该用户的姓名或者年龄或者生日；
       实现方式：Redis Hash 对应 Value 内部实际就是一个 HashMap，实际这里会有 2 种不同实现，这个 Hash 的成员比较少时 Redis 为了节省内存会采用类似
            一维数组的方式来紧凑存储，而不会采用真正的 HashMap 结构，对应的 value redisObject 的 encoding 为 zipmap, 当成员数量增大时会自动转成真正的 HashMap,
            此时 encoding 为 ht

    3. List
       常用命令：lpush/rpush/lpop/rpop/lrange 等；
       应用场景：Redis list 的应用场景非常多，也是 Redis 最重要的数据结构之一，比如 twitter 的关注列表，粉丝列表等都可以用 Redis 的 list 结构来实现；消息队列；
       实现方式：Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis 内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。

    4. Set数据
       常用命令：sadd/spop/smembers/sunion 等；
       应用场景：Redis set 对外提供的功能与 list 类似是一个列表的功能，特殊之处在于 set 是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，
            set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的；
       实现方式：set 的内部实现是一个 value 永远为 null 的 HashMap，实际就是通过计算 hash 的方式来快速排重的，这也是 set 能提供判断一个成员是否在集合内的原因

    5. Sorted Set数据
       常用命令：zadd/zrange/zrem/zcard 等；
       应用场景：Redis sorted set 的使用场景与 set 类似，区别是 set 不是自动有序的，而 sorted set 可以通过用户额外提供一个优先级 (score) 的参数来为成员排序，
            并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择 sorted set 数据结构，比如 twitter 的 public timeline 可以以发表时间作为 score 来存储，这样获取时就是自动按时间排好序的。
       实现方式：Redis sorted set 的内部使用 HashMap 和跳跃表 (SkipList) 来保证数据的存储和有序，HashMap 里放的是成员到 score 的映射，而跳跃表里存放的
            是所有的成员，排序依据是 HashMap 里存的 score, 使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。

三、 Redis 持久化
    Redis 可以以 master-slave 的方式配置服务器，Slave 节点对数据进行 replica 备份，Slave 节点也可以充当 Read only 的节点分担数据读取的工作。
    Redis 虽然是基于内存的存储系统，但是它本身是支持内存数据的持久化的，而且提供两种主要的持久化策略：RDB 快照和 AOF 日志
    Redis 内建支持两种持久化方案，snapshot 快照和 AOF 增量 Log 方式。快照顾名思义就是隔一段时间将完整的数据 Dump 下来存储在文件中。A
        OF 增量 Log 则是记录对数据的修改操作（实际上记录的就是每个对数据产生修改的命令本身），两种方案可以并存，也各有优缺点

四、 Redis 的 7 个应用场景
    1. 缓存 —— 热数据：
        热点数据（经常会被查询，但是不经常被修改或者删除的数据）
    2. 计数器： 统计点击数等应用
    3. 队列： 相当于消息系统； 队列不仅可以把并发请求变成串行，并且还可以做队列或者栈使用
    4. 位操作（大数据处理）：
        用于数据量上亿的场景下，例如几亿用户系统的签到，去重登录次数统计，某用户是否在线状态等等。
        想想一下腾讯 10 亿用户，要几个毫秒内查询到某个用户是否在线，你能怎么做？千万别说给每个用户建立一个 key，然后挨个记（你可以算一下需要的内存会很恐怖，而且这种类似的需求很多，腾讯光这个得多花多少钱。。）好吧。这里要用到位操作 —— 使用 setbit、getbit、bitcount 命令。
        原理是：redis 内构建一个足够长的数组，每个数组元素只能是 0 和 1 两个值，然后这个数组的下标 index 用来表示我们上面例子里面的用户 id（必须是数字哈），那么很显然，这个几亿长的大数组就能通过下标和元素值（0 和 1）来构建一个记忆系统，上面我说的几个场景也就能够实现。用到的命令是：setbit、getbit、bitcount
    5. 分布式锁与单线程机制：
        验证前端的重复请求（可以自由扩展类似情况），可以通过 redis 进行过滤：每次请求将 request Ip、参数、接口等 hash 作为 key 存储 redis（幂等性请求），设置多长时间有效期，然后下次请求过来的时候先在 redis 中检索有没有这个 key，进而验证是不是一定时间内过来的重复提交
        秒杀系统，基于 redis 是单线程特征，防止出现数据库 “爆破”
        全局增量 ID 生成，类似 “秒杀”
    6. 最新列表：
        例如新闻列表页面最新的新闻列表，如果总数量很大的情况下，尽量不要使用 select a from A limit 10 这种 low 货，尝试 redis 的 LPUSH 命令构建 List，
        一个个顺序都塞进去就可以啦。不过万一内存清掉了咋办？也简单，查询不到存储 key 的话，用 mysql 查询并且初始化一个 List 到 redis 中就好了。
    7. 排行榜
        谁得分高谁排名往上。命令：ZADD（有续集，sorted set）

五、 Redis集群的数据一致性（redis分布式）
    Redis 集群没有使用一致性hash, 而是引入了哈希槽的概念。
    Reds 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽。
    这种结构很容易添加或者删除节点，并且无论是添加删除或者修改某一个节点，都不会造成集群不可用的状态。
    使用哈希槽的好处就在于可以方便的添加或移除节点。
    当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；
    当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了；
    在这一点上，我们以后新增或移除节点的时候不用先停掉所有的 redis 服务

    通过key做一致性哈希，实现key对应redis结点的分布。
    一致性哈希的实现：
    l        hash值计算：通过支持MD5与MurmurHash两种计算方式，默认是采用MurmurHash，高效的hash计算。
    l        一致性的实现：通过java的TreeMap来模拟环状结构，实现均匀分布

六、 MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据
    相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。
    redis 提供 6种数据淘汰策略：
       voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
       volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
       volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
       allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
       allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
       no-enviction（驱逐）：禁止驱逐数据

七、 Redis哨兵机制（Sentinel）
     Redis的哨兵(sentinel) 系统用于管理多个 Redis 服务器：
        监控(Monitoring): 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。
        提醒(Notification):当被监控的某个 Redis出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。
        自动故障迁移(Automatic failover):当一个Master不能正常工作时，哨兵(sentinel) 会开始一次自动故障迁移操作,它会将失效Master的其中一个Slave升级为新的Master,
            并让失效Master的其他Slave改为复制新的Master; 当客户端试图连接失效的Master时,集群也会向客户端返回新Master的地址,使得集群可以使用Master代替失效Master。
        哨兵(sentinel) 是一个分布式系统,你可以在一个架构中运行多个哨兵(sentinel) 进程,这些进程使用流言协议(gossipprotocols)来接收关于Master是否下线的信息,
            并使用投票协议(agreement protocols)来决定是否执行自动故障迁移,以及选择哪个Slave作为新的Master。

     工作原理：
        1.三个定时监控任务：
            1.1 每隔10s，每个S节点（哨兵节点）会向主节点和从节点发送info命令获取最新的拓扑结构
            1.2 每隔2s，每个S节点会向某频道上发送该S节点对于主节点的判断以及当前Sl节点的信息，
                同时每个Sentinel节点也会订阅该频道，来了解其他S节点以及它们对主节点的判断（做客观下线依据）
            1.3 每隔1s，每个S节点会向主节点、从节点、其余S节点发送一条ping命令做一次心跳检测(心跳检测机制)，来确认这些节点当前是否可达
        2.主客观下线：
            2.1主观下线：根据第三个定时任务对没有有效回复的节点做主观下线处理
            2.2客观下线：若主观下线的是主节点，会咨询其他S节点对该主节点的判断，超过半数，对该主节点做客观下线
        3.选举出某一哨兵节点作为领导者，来进行故障转移。选举方式：raft算法。每个S节点有一票同意权，哪个S节点做出主观下线的时候，
            就会询问其他S节点是否同意其为领导者。获得半数选票的则成为领导者。基本谁先做出客观下线，谁成为领导者。

八、 顺序队列与循环队列
    队列本身也是一种线性表，因而和线性表一样也有顺序和链式存储结构两种存储方式。
    采用顺序存储结构实现的队列称为顺序队列；
    采用链式存储结构实现的队列称为链队列。

    1. 顺序队列中的溢出现象：
        ① "下溢"现象
           当队列为空时，做出队运算产生的溢出现象。“下溢”是正常现象，常用作程序控制转移的条件。
        ② "真上溢"现象
           当队列满时，做进栈运算产生空间溢出的现象。“真上溢”是一种出错状态，应设法避免。
        ③ "假上溢"现象
        　 由于入队和出队操作中，头尾指针只增加不减小，致使被删元素的空间永远无法重新利用。当队列中实际的元素个数远远小于向量空间的规模时，
            也可能由于尾指针已超越向量空间的上界而不能做入队操作。该现象称为"假上溢"现象。

    2. 循环队列
        为充分利用向量空间，克服"假上溢"现象的方法是：将向量空间想象为一个首尾相接的圆环，并称这种向量为循环向量。存储在其中的队列称为循环队列




```


9. PHP使用redis防止大并发下二次写入
    * PHP调用redis进去读写操作，大并发下会出现：读取key1，没有内容则写入内容，
        但是大并发下会出现同时多个php进程写入的情况，这个时候需要加一个锁，
        即获取锁的php进程有权限写。
        ```
        $lock_key = 'LOCK_PREFIX' . $redis_key;
        $is_lock = $redis->setnx($lock_key, 1); // 加锁
        if($is_lock == true){ // 获取锁权限
            $redis->setex($redis_key, $expire, $data); // 写入内容
            // 释放锁
            $redis->del($lock_key);
        }else{
            return true; // 获取不到锁权限，直接返回
        }
        ```

    * 思路是：设置一个锁的key，setnx是原子操作，只能一个进程写入成功，
        写入成功返回true（表示获取锁权限），然后写入内容再释放锁即删除锁key。
        获取不到锁的进程直接返回。但是这里有种情况，获取锁权限的进程，获取锁后运行报错了，
        导致没有释放锁，那么一直就不能写入内容，这时就需要拿不到锁权限的进程去判断锁的剩余有效时间，
        如果为-1则设置锁的有效时间为5秒（预留5秒给拿到锁的进程的运行时间，足够多了）。
        改良后的代码：
        ```
        $lock_key = 'LOCK_PREFIX' . $redis_key;
        $is_lock = $redis->setnx($lock_key, 1); // 加锁
        if($is_lock == true){ // 获取锁权限
            $redis->setex($redis_key, $expire, $data); // 写入内容
            // 释放锁
            $redis->del($lock_key);
        }else{
            // 防止死锁
            if($redis->ttl($lock_key) == -1){
                $redis->expire($lock_key, 5);
            }
            return true; // 获取不到锁权限，直接返回
        }
        ```

10.  Redis缓存5大难题
    * （1）缓存雪崩：缓存雪崩表示在某一时间段，缓存集中失效，导致请求全部走数据库，
    有可能搞垮数据库，使整个服务瘫痪。
        * 使缓存集中失效的原因：
            1、redis服务器挂掉了。
            2、对缓存数据设置了相同的过期时间，导致某时间段内缓存集中失效。
        * 如何解决缓存集中失效：
            1、针对原因1，可以实现redis的高可用，Redis Cluster 或者 Redis Sentinel(哨兵) 等方案。
            2、针对原因2，设置缓存过期时间时加上一个随机值，避免缓存在同一时间过期。
            3、使用双缓存策略，设置两个缓存，原始缓存和备用缓存，原始缓存失效时，
            访问备用缓存，备用缓存失效时间设置长点。
            ```
            //原始缓存
            $redis->set('article_content_2', '文章内容', 60);
            //设置备用缓存，失效时间设置长点
            $redis->set('article_content_backup_2', '文章内容', 1800);
            ```
            
    * （2）缓存穿透：查询一个一定不存在的数据，由于没有获取到缓存，所以没写入缓存，
            导致这个不存在的数据每次都需要去数据库查询，失去了缓存的意义。
            请求的数据大量的没有获取到缓存，导致走数据库，有可能搞垮数据库，使整个服务瘫痪。
        * 比如文章表，一般我们的主键ID都是无符号的自增类型，有些人想要搞垮你的数据库，
                每次请求都用负数ID，而ID为负数的记录在数据库根本就没有。
        * 解决方案：
                1、对于像ID为负数的非法请求直接过滤掉，采用布隆过滤器(Bloom Filter)。
                2、针对在数据库中找不到记录的，我们仍然将该空数据存入缓存中，当然一般会设置一个较短的过期时间。
                
        * （3）缓存击穿表示某个key的缓存非常热门，有很高的并发一直在访问，如果该缓存失效，
                那同时会走数据库，压垮数据库。
            * 缓存击穿与缓存雪崩的区别是这里针对的是某一热门key缓存，而雪崩针对的是大量缓存的集中失效。
            * 解决方案：
                        1、让该热门key的缓存永不过期。
                        2、使用互斥锁，通过redis的setnx实现互斥锁。
                ```
                        function getRedis(){
                            $redis = new Redis();
                            $redis->connect('127.0.0.1', 6379, 60);
                            return $redis;
                        }
                        
                        //加锁
                        function lock($key, $random){
                            $redis = getRedis();
                            //设置锁的超时时间，避免释放锁失败，del()操作失败，产生死锁。
                            $ret = $redis->set($key, $random, ['nx', 'ex' => 3 * 60]);
                            return $ret;
                        }
                        
                        //解锁
                        function unLock($key, $random){
                            $redis = getRedis();
                            //这里的随机数作用是，防止更新缓存操作时间过长，超过了锁的有效时间，导致其他请求拿到了锁。
                            //但上一个请求更新缓存完毕后，如果不加判断直接删除锁，就会误删其他请求创建的锁。
                            if ($redis->get($key) == $random) {
                                $redis->del($key);
                            }
                        }
                        
                        //从缓存中获取文章数据
                        function getArticleInCache($id){
                            $redis = getRedis();
                            $key = 'article_content_' . $id;
                            $ret = $redis->get($key);
                            if ($ret === false) {
                                //生成锁的key
                                $lockKey = $key . '_lock';
                                //生成随机数，用于设置锁的值，后面释放锁时会用到
                                $random = mt_rand();
                                //拿到互斥锁
                                if (lock($lockKey, $random)) {
                                    //这里是伪代码，表示从数据库中获取文章数据
                                    $value = $db->getArticle($id);
                                    //更新缓存，过期时间可以根据情况自已调整
                                    $redis->set($key, $value, 2 * 60);
                                    //释放锁
                                    unLock($lockKey, $random);
                                } else {
                                    //等待200毫秒，然后重新获取缓存值，让其他获取到锁的进程取得数据并设置缓存
                                    usleep(200);
                                    getArticleInCache($id);
                                }
                            } else {
                                return $ret;
                            }
                        }
                        ```
    * （4）缓存并发：
            这里的并发指的是多个redis的client同时setkey引起的并发问题。其实redis自身就是单线程操作，
            多个client并发操作，按照先到先执行的原则，先到的先执行，其余的阻塞。当然，
            另外的解决方案是把redis.set操作放在队列中使其串行化，必须的一个一个执行。
            
    * （5）缓存预热：
        缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。
        这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，
        用户直接查询事先被预热的缓存数据。
        解决思路：
        1、直接写个缓存刷新页面，上线时手工操作下。
        2、数据量不大，可以在项目启动的时候自动进行加载。
        目的就是在系统上线前，将数据加载到缓存中。








